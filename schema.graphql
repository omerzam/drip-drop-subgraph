"""
Transaction data, including hash and timestamp
"""
type Transaction @entity {
  """
  ID is transaction hash
  """
  id: ID!
  blockNumber: BigInt!
  # timestamp txn was confirmed
  timestamp: BigInt!
  # gas used during txn execution
  # gasUsed: BigInt!
  gasPrice: BigInt!
  # tx index
  index: BigInt!
  from: Bytes!
  to: Bytes
  value: BigInt!
  gasLimit: BigInt!
}

type Token @entity {
  # token address
  id: ID!
  # token symbol
  symbol: String!
  # token name
  name: String!
  # token total supply
  totalSupply: BigInt!
  # token owner
  owner: User!

  createdAtTx: Transaction!

  updatedAtTx: Transaction!
  # items
  items: [Item!] @derivedFrom(field: "token")
}

type User @entity {
  id: ID!
  isAdmin: Boolean!
  isMinter: Boolean!
  isOperator: Boolean!
  tokens: [Token!] @derivedFrom(field: "owner")
  items: [Item!] @derivedFrom(field: "owner")
  bids: [Bid!] @derivedFrom(field: "bidder")
}

enum ItemState {
  New
  OnSale
  OfferAccepted
  SaleRetracted
  Sold
}

type Item @entity {
  # Token address + itemRef
  id: ID!
  state: ItemState!
  itemRef: BigInt! # uint256
  token: Token! # address
  token_id: BigInt! # uint256
  owner: User! # address
  uri: String! # string
  royalty: BigInt! # uint256
  timestamp: BigInt!
  itemOnSale: ItemOnSale
}

type Bid @entity {
  id: ID!
  bidder: User! # address
  tokenId: BigInt! # uint256
  bid: BigInt! # uint256
}

#### GENERATED BY SCAFFOLD SCRIPT - Add any custom entities before this line

type Admin @entity {
  id: ID!
  isAdmin: Boolean! # bool
  userAddress: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Minter @entity {
  id: ID!
  isMinter: Boolean! # bool
  userAddress: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Operator @entity {
  id: ID!
  isOperator: Boolean! # bool
  userAddress: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type OwnershipTransferred @entity {
  id: ID!
  previousOwner: Bytes! # address
  newOwner: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}
type BidIncreased @entity {
  id: ID!
  bidder: Bytes! # address
  tokenId: BigInt! # uint256
  previous_bid: BigInt! # uint256
  this_bid: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type BidReceived @entity {
  id: ID!
  bidder: Bytes! # address
  tokenId: BigInt! # uint256
  bid: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type ItemAdded @entity {
  id: ID!
  itemRef: BigInt! # uint256
  token_address: Bytes! # address
  token_id: BigInt! # uint256
  owner: User! # address
  uri: String! # string
  royalty: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type ItemOnSale @entity {
  id: ID!
  item: Item!
  itemRef: BigInt! # uint256
  contract_address: Bytes! # address
  tokenId: BigInt! # uint256
  asking_price: BigInt! # uint256
  payment_token: Bytes! # address
  uri: String! # string
  royalty: BigInt! # uint256
  owner: Bytes! # address
  resale: Boolean! # bool
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type MetaTransactionExecuted @entity {
  id: ID!
  userAddress: Bytes! # address
  relayerAddress: Bytes! # address
  functionSignature: Bytes! # bytes
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type NewOffer @entity {
  id: ID!
  tokenId: BigInt! # uint256
  owner: Bytes! # address
  price: BigInt! # uint256
  hash: String! # string
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type OfferAccepted @entity {
  id: ID!
  buyer: Bytes! # address
  seller: Bytes! # address
  itemRef: BigInt! # uint256
  contract_address: Bytes! # address
  tokenId: BigInt! # uint256
  price: BigInt! # uint256
  payment_token: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Payment @entity {
  id: ID!
  wallet: Bytes! # address
  creator: Bytes! # address
  _owner: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Royalties @entity {
  id: ID!
  # first_payees: [Bytes]! # address[]
  # first_shares: [BigInt]! # uint256[]
  # resale_payees: [Bytes]! # address[]
  # resale_shares: [BigInt]! # uint256[]
  itemRef: BigInt! # uint256
  tokenId: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type SaleResubmitted @entity {
  id: ID!
  tokenId: BigInt! # uint256
  price: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type SaleRetracted @entity {
  id: ID!
  owner: Bytes! # address
  itemRef: BigInt! # uint256
  contract_address: Bytes! # address
  tokenId: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type SharesUpdated @entity {
  id: ID!
  ownerShare: BigInt! # uint256
  creatorShare: BigInt! # uint256
  divisor: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type WalletTransferred @entity {
  id: ID!
  previousWallet: Bytes! # address
  newWallet: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}
type Approval @entity {
  id: ID!
  owner: Bytes! # address
  approved: Bytes! # address
  tokenId: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type ApprovalForAll @entity {
  id: ID!
  owner: Bytes! # address
  operator: Bytes! # address
  approved: Boolean! # bool
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type OperatorSet @entity {
  id: ID!
  operator: Bytes! # address
  enabled: Boolean! # bool
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Transfer @entity {
  id: ID!
  from: Bytes! # address
  to: Bytes! # address
  tokenId: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type NewTokenIssued @entity {
  id: ID!
  pos: BigInt! # uint256
  name: String! # string
  symbol: String! # string
  dr: Bytes! # address
  sale_address: Bytes! # address
  proxyregistry: Bytes! # address
  owner: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}
